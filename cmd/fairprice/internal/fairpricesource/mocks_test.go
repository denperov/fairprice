// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fairpricesource_test

import (
	"sync"
	"tickerprice/cmd/fairprice/internal/fairpricesource"
	"tickerprice/cmd/fairprice/internal/types"
)

// Ensure, that PriceAlgorithmMock does implement fairpricesource.PriceAlgorithm.
// If this is not the case, regenerate this file with moq.
var _ fairpricesource.PriceAlgorithm = &PriceAlgorithmMock{}

// PriceAlgorithmMock is a mock implementation of fairpricesource.PriceAlgorithm.
//
// 	func TestSomethingThatUsesPriceAlgorithm(t *testing.T) {
//
// 		// make and configure a mocked fairpricesource.PriceAlgorithm
// 		mockedPriceAlgorithm := &PriceAlgorithmMock{
// 			CalculatePriceFunc: func(prices map[types.SourceID]float64) (float64, error) {
// 				panic("mock out the CalculatePrice method")
// 			},
// 		}
//
// 		// use mockedPriceAlgorithm in code that requires fairpricesource.PriceAlgorithm
// 		// and then make assertions.
//
// 	}
type PriceAlgorithmMock struct {
	// CalculatePriceFunc mocks the CalculatePrice method.
	CalculatePriceFunc func(prices map[types.SourceID]float64) (float64, error)

	// calls tracks calls to the methods.
	calls struct {
		// CalculatePrice holds details about calls to the CalculatePrice method.
		CalculatePrice []struct {
			// Prices is the prices argument value.
			Prices map[types.SourceID]float64
		}
	}
	lockCalculatePrice sync.RWMutex
}

// CalculatePrice calls CalculatePriceFunc.
func (mock *PriceAlgorithmMock) CalculatePrice(prices map[types.SourceID]float64) (float64, error) {
	if mock.CalculatePriceFunc == nil {
		panic("PriceAlgorithmMock.CalculatePriceFunc: method is nil but PriceAlgorithm.CalculatePrice was just called")
	}
	callInfo := struct {
		Prices map[types.SourceID]float64
	}{
		Prices: prices,
	}
	mock.lockCalculatePrice.Lock()
	mock.calls.CalculatePrice = append(mock.calls.CalculatePrice, callInfo)
	mock.lockCalculatePrice.Unlock()
	return mock.CalculatePriceFunc(prices)
}

// CalculatePriceCalls gets all the calls that were made to CalculatePrice.
// Check the length with:
//     len(mockedPriceAlgorithm.CalculatePriceCalls())
func (mock *PriceAlgorithmMock) CalculatePriceCalls() []struct {
	Prices map[types.SourceID]float64
} {
	var calls []struct {
		Prices map[types.SourceID]float64
	}
	mock.lockCalculatePrice.RLock()
	calls = mock.calls.CalculatePrice
	mock.lockCalculatePrice.RUnlock()
	return calls
}

// Ensure, that PriceStorageMock does implement fairpricesource.PriceStorage.
// If this is not the case, regenerate this file with moq.
var _ fairpricesource.PriceStorage = &PriceStorageMock{}

// PriceStorageMock is a mock implementation of fairpricesource.PriceStorage.
//
// 	func TestSomethingThatUsesPriceStorage(t *testing.T) {
//
// 		// make and configure a mocked fairpricesource.PriceStorage
// 		mockedPriceStorage := &PriceStorageMock{
// 			AddPriceFunc: func(ticker types.Ticker, timeslot types.Timeslot, sourceID types.SourceID, price string)  {
// 				panic("mock out the AddPrice method")
// 			},
// 			GetPricesFunc: func(ticker types.Ticker, timeslot types.Timeslot) map[types.SourceID]string {
// 				panic("mock out the GetPrices method")
// 			},
// 			RemovePricesFunc: func(ticker types.Ticker, timeslot types.Timeslot)  {
// 				panic("mock out the RemovePrices method")
// 			},
// 		}
//
// 		// use mockedPriceStorage in code that requires fairpricesource.PriceStorage
// 		// and then make assertions.
//
// 	}
type PriceStorageMock struct {
	// AddPriceFunc mocks the AddPrice method.
	AddPriceFunc func(ticker types.Ticker, timeslot types.Timeslot, sourceID types.SourceID, price string)

	// GetPricesFunc mocks the GetPrices method.
	GetPricesFunc func(ticker types.Ticker, timeslot types.Timeslot) map[types.SourceID]string

	// RemovePricesFunc mocks the RemovePrices method.
	RemovePricesFunc func(ticker types.Ticker, timeslot types.Timeslot)

	// calls tracks calls to the methods.
	calls struct {
		// AddPrice holds details about calls to the AddPrice method.
		AddPrice []struct {
			// Ticker is the ticker argument value.
			Ticker types.Ticker
			// Timeslot is the timeslot argument value.
			Timeslot types.Timeslot
			// SourceID is the sourceID argument value.
			SourceID types.SourceID
			// Price is the price argument value.
			Price string
		}
		// GetPrices holds details about calls to the GetPrices method.
		GetPrices []struct {
			// Ticker is the ticker argument value.
			Ticker types.Ticker
			// Timeslot is the timeslot argument value.
			Timeslot types.Timeslot
		}
		// RemovePrices holds details about calls to the RemovePrices method.
		RemovePrices []struct {
			// Ticker is the ticker argument value.
			Ticker types.Ticker
			// Timeslot is the timeslot argument value.
			Timeslot types.Timeslot
		}
	}
	lockAddPrice     sync.RWMutex
	lockGetPrices    sync.RWMutex
	lockRemovePrices sync.RWMutex
}

// AddPrice calls AddPriceFunc.
func (mock *PriceStorageMock) AddPrice(ticker types.Ticker, timeslot types.Timeslot, sourceID types.SourceID, price string) {
	if mock.AddPriceFunc == nil {
		panic("PriceStorageMock.AddPriceFunc: method is nil but PriceStorage.AddPrice was just called")
	}
	callInfo := struct {
		Ticker   types.Ticker
		Timeslot types.Timeslot
		SourceID types.SourceID
		Price    string
	}{
		Ticker:   ticker,
		Timeslot: timeslot,
		SourceID: sourceID,
		Price:    price,
	}
	mock.lockAddPrice.Lock()
	mock.calls.AddPrice = append(mock.calls.AddPrice, callInfo)
	mock.lockAddPrice.Unlock()
	mock.AddPriceFunc(ticker, timeslot, sourceID, price)
}

// AddPriceCalls gets all the calls that were made to AddPrice.
// Check the length with:
//     len(mockedPriceStorage.AddPriceCalls())
func (mock *PriceStorageMock) AddPriceCalls() []struct {
	Ticker   types.Ticker
	Timeslot types.Timeslot
	SourceID types.SourceID
	Price    string
} {
	var calls []struct {
		Ticker   types.Ticker
		Timeslot types.Timeslot
		SourceID types.SourceID
		Price    string
	}
	mock.lockAddPrice.RLock()
	calls = mock.calls.AddPrice
	mock.lockAddPrice.RUnlock()
	return calls
}

// GetPrices calls GetPricesFunc.
func (mock *PriceStorageMock) GetPrices(ticker types.Ticker, timeslot types.Timeslot) map[types.SourceID]string {
	if mock.GetPricesFunc == nil {
		panic("PriceStorageMock.GetPricesFunc: method is nil but PriceStorage.GetPrices was just called")
	}
	callInfo := struct {
		Ticker   types.Ticker
		Timeslot types.Timeslot
	}{
		Ticker:   ticker,
		Timeslot: timeslot,
	}
	mock.lockGetPrices.Lock()
	mock.calls.GetPrices = append(mock.calls.GetPrices, callInfo)
	mock.lockGetPrices.Unlock()
	return mock.GetPricesFunc(ticker, timeslot)
}

// GetPricesCalls gets all the calls that were made to GetPrices.
// Check the length with:
//     len(mockedPriceStorage.GetPricesCalls())
func (mock *PriceStorageMock) GetPricesCalls() []struct {
	Ticker   types.Ticker
	Timeslot types.Timeslot
} {
	var calls []struct {
		Ticker   types.Ticker
		Timeslot types.Timeslot
	}
	mock.lockGetPrices.RLock()
	calls = mock.calls.GetPrices
	mock.lockGetPrices.RUnlock()
	return calls
}

// RemovePrices calls RemovePricesFunc.
func (mock *PriceStorageMock) RemovePrices(ticker types.Ticker, timeslot types.Timeslot) {
	if mock.RemovePricesFunc == nil {
		panic("PriceStorageMock.RemovePricesFunc: method is nil but PriceStorage.RemovePrices was just called")
	}
	callInfo := struct {
		Ticker   types.Ticker
		Timeslot types.Timeslot
	}{
		Ticker:   ticker,
		Timeslot: timeslot,
	}
	mock.lockRemovePrices.Lock()
	mock.calls.RemovePrices = append(mock.calls.RemovePrices, callInfo)
	mock.lockRemovePrices.Unlock()
	mock.RemovePricesFunc(ticker, timeslot)
}

// RemovePricesCalls gets all the calls that were made to RemovePrices.
// Check the length with:
//     len(mockedPriceStorage.RemovePricesCalls())
func (mock *PriceStorageMock) RemovePricesCalls() []struct {
	Ticker   types.Ticker
	Timeslot types.Timeslot
} {
	var calls []struct {
		Ticker   types.Ticker
		Timeslot types.Timeslot
	}
	mock.lockRemovePrices.RLock()
	calls = mock.calls.RemovePrices
	mock.lockRemovePrices.RUnlock()
	return calls
}
